# GTEgorss
Programming technologies (.NET: C#, F#; JVM: Java, Scala)

##LAB-1: Interop and learning about new programming and developing tools


### <ins>Task 1</ins>
Изучить механизм интеропа между языками, попробовать у себя вызывать C/C++ (Не C++/CLI) код (суммы чисел достаточно) из Java и C#. В отчёте описать логику работы, сложности и ограничения этих механизмов.

Процесс:
1. Написал на С++ две функции: sum(int a, int b) и int mult()
2. Добавил в заголовочный файл extern и __declspec(dllexport), чтобы функции в библиотеке после сборки соотвествовале по сигнатуре функциям из source-кода
3. Изменил в CMake файле add_executable на add_library, и добавил в аргументы имя заголовочного файла. В результате этого получил .dylib (macOS аналог .dll)

<ins>Что такое .dylib?</ins>

Файл с расширением файла DYLIB является файлом динамической библиотеки Mach-O (Mach Object), который приложение ссылается во время выполнения, чтобы выполнять определенные функции по мере необходимости.

Mach-O - это формат файла, который используется для различных типов файлов, включая объектный код, общие библиотеки, дампы ядра и исполняемые файлы, поэтому они могут содержать общие данные, которые несколько приложений могут повторно использовать с течением времени.

4. Сохранил файл .dylib в проекты на C# и на Java
5. В Используя атрибут DLLImport, "законнектил" декларацию функций в C# с их определением в .dylib
6. В Java с помощью внешне установленной библиотеки JNA создал .class на основе interface, содержащего функции, совпадающие по сигнатуре с функциями в .dylib

### Сложности и ограничения:

-Нужно подключать и настраивать дополнительные инструменты, которые обычно не используются
-Нет простого способа изменять .dylib/.dll. Нужно изменять source-код на C++, build-ить и только после этого получить новую .dylib/.dll
-Нельзя в качестве аргументов использовать не стандартные типы, ибо в другом языке не получится сопоставить сигнатуру и при интеропе линковка с .dylib/.dll не произойдёт


### <ins>Task 2</ins>
Написать немного кода на Scala и F# с использованием уникальных возможностей языка - Pipe operator, Discriminated Union, Computation expressions и т.д. . Вызвать написанный код из обычных соответствующих ООП языков (Java и С#) и посмотреть во что превращается написанный раннее код после декомпиляции в них. 

Процесс C#/F#:
1. Познакомился с F#: println, let, type, аргументы у функций
2. Создал 3 файла на каждую из фичей: Pipe operator, Discriminated union, Computation expression
3. Создал проект на C#, добавил refernce на F# проект и запустил созданные функции
4. Вбил код на F# в sharplab.io, дабы посмотреть, как его .NET декомпилирует в C#

Процесс Java/Scala:
1. Установил Scala в Intellij IDEA и добавил в модуль проекта
2. Познакомился со Scala: object, class, case class, def и определение фунции, наследование extends
3. Написал 2 скрипта на каждую из двух фичей: Pattern matching и особая форма цикла For c условием
4. В том же проекте создал файл .java и вызвал оттуда функции из Scala
5. Открыл .class, соотвествующий коду на Scala, чтобы посмотреть, в какой код на Java переведёт его JVM


### Вывод:
-Java и Scala компилируются в один и тот же байткод JVM, поэтому могут быть использованы в одном проекте
-C# и F# компилируются в IL, поэтому с добавлением refernce могут обмениваться функционалом между проектами


### <ins>Task 3</ins>
Написать алгоритм обхода графа (DFS и BFS) на языке Java, собрать в пакет и опубликовать (хоть в Maven, хоть в Gradle, не имеет значения). Использовать в другом проекте на Java/Scala этот пакет. Повторить это с C#/F#. В отчёте написать про алгоритм работы пакетных менеджеров, особенности их работы в C# и Java мирах.

Процесс Java:
1. Написал DFS и BFS на Java и с помощью инструментов Intellij IDEA создал .jar файл
2. Подключил Maven Framework и подготовил pom.xml файл для публикации в Maven Central
3. Получил репозиторий на Maven (на этом пункте возникли проблемы, я его ещё не получил)
4. Загрузил подготовленные артефакты в Maven репозиторий
5. Чтобы теперь нам в новом проекте воспользоваться нашей библиотекой .jar, нам нужно пометстить подключить Maven framework и добавить dependency в файл pom.xml с соответствующими groupId, artifactId и version тегами
6. Использовал функционал, добавленный вместе с библиотекой таким образом. (Несмотря на то, что я не сделал это со своим пакетом, я сделал это во время выполнения следующего пункта лабораторной)
7. Проверил работу .jar в Java/Scala в отдельном проекте

Процесс C#:
1. Создал проект с начально конфигурацией "Class Library"
2. Написал DFS и BFS на С# и с помощью инструментов Finder нашёл созданную после build-а .dll
3. Опубликовал эту библиотеку в пакетном менеджере (та же проблема, что и в Java)
4. Загрузил пакет с .dll в другой проект и добавил refernce на файл .dll
5. Попробовал вызов функционала .dll из C# и из F# проектов


### <ins>Task 4</ins>
Изучить инструменты для оценки производительности в C# и Java. Написать несколько алгоритмов сортировок (и взять стандартную) и запустить бенчмарки (в бенчмарках помимо времени выполнения проверить аллокации памяти). В отчёт написать про инструменты для бенчмаркинга, их особености, анализ результатов проверок.

Процесс:
1. На C# и Java написал сортировки Bubble sort, Merge sort и Quick sort
2. Создал общих класс Sort, который содержит массив целых чисел как поле и сортирует этот массив всеми должными способами по заданию: мои сортировки и стандартная сортировка
3. В C# использовал пакет для измерений производительности BenchmarkDotNet, который был установлен с помощью NuGet пакет менеджера
4. Добавил требуемые атрибуты для отслеживания выполнения!
5. Получил результат

<img width="742" alt="Screenshot 2022-03-03 at 23 00 24" src="https://user-images.githubusercontent.com/37060880/156707107-9fa4bbea-85da-4638-8fbd-dacd2c2fe568.png">

<img width="732" alt="Screenshot 2022-03-03 at 23 04 41" src="https://user-images.githubusercontent.com/37060880/156707090-3af3d883-debd-4acc-af4f-672e7acd7c81.png">

6. Для Java воспользовал Maven Framework и добавление dependencies для установки библиотеки jmh-core-1.34.jar, которая отвечает за бенчмарк в Java
7. Так же расставил требуемые атрибуты и получил результат:


Result "src.main.java.Sort.BubbleSortBenchmark":
  N = 7
  mean =   1375.080 ±(99.9%) 4074.936 us/op
  
  
Result "src.main.java.Sort.DefaultSortBenchmark":
  N = 7
  mean =    361.001 ±(99.9%) 576.744 us/op
  
  
Result "src.main.java.Sort.MergeSortBenchmark":
  N = 7
  mean =    776.409 ±(99.9%) 1550.454 us/op
  
  
Result "src.main.java.Sort.QuickSortBenchmark":
  N = 7
  mean =    464.966 ±(99.9%) 1480.167 us/op
  
  По инфомации от студентов и преподавателей, отслежить в бенчмарках Java слишком сложная задача, поэтому аллокация не вошла в результат
  В каждом из пакетов с бенчмарками есть данные о warm up итерациях, которые можно настроить. В Java, например, после нескольких вызовов функции JVM пытается перевести её в байткод для оптимизации процесса
  
  Судя по бенчмаркам (от самого медленного к самому быстрому):
  1. Bubble sort
  2. Merge sort
  3. Quick sort
  4. Std sort

По количеству занимаемой памяти с большим отрывом выделяется Merge sort, ибо, как известно, в процессе инициализируется большое количество подмассивов


### <ins>Task 5</ins>
Используя инструменты dotTrace, dotMemory, всё-что-угодно-хоть-windbg, проанализировать работу написанного кода для бекапов. Необходимо написать сценарий, когда в цикле будет выполняться много запусков, будут создаваться и удаляться точки. Проверить два сценария: с реальной работой с файловой системой и без неё. В отчёте неоходимо проанализировать полученные результаты, сделать вывод о написанном коде. Опционально: предложить варианты по модернизации или написать альтернативную имплементацию.

Проблемный пункт в связи с выполнением лабораторной работе на macOS

Процесс:
1. Установил command-line dotMemory для macOS
2. В бекапах написал тест, который создаёт 15 бекап джоб и в каждой по рестор поинту
3. С помощью Thread.Sleep() и ##dotMemory["get-snapshot", {pid:<pid>}] сделал 3 snap shot-а:
  -В начале работы
  -После создания 15 джоб
  -После распаковки 15 рестор поинтов
4, Результат:
![image_2022-03-04_07-10-28](https://user-images.githubusercontent.com/37060880/156709748-b9540849-2be1-40d4-8a09-2f7a9422660a.png)

### Анализ увиденного:  
  
Видно, как сначала память не изменяется
  
При появлении джоб возрастает сразу после их создания
  
Потом начинается процесс обработки и распаковки рестор поинтов. Занимаемая память линейно возрастает
  
В конце распаковки метод заканчивает выполнять свой функционал, и начинается процесс удаления объектов после выхода из метода. Занимаемая память убывает
