# GTEgorss
Programming technologies (.NET: C#, F#; JVM: Java, Scala)

## LAB-1: Interop and learning about new programming and developing tools


### <ins>Task 1</ins>
Изучить механизм интеропа между языками, попробовать у себя вызывать C/C++ (Не C++/CLI) код (суммы чисел достаточно) из Java и C#. В отчёте описать логику работы, сложности и ограничения этих механизмов.

Процесс:
1. Написал на С++ две функции: sum(int a, int b) и int mult()
2. Добавил в заголовочный файл extern и __declspec(dllexport), чтобы функции в библиотеке после сборки соотвествовале по сигнатуре функциям из source-кода
3. Изменил в CMake файле add_executable на add_library, и добавил в аргументы имя заголовочного файла. В результате этого получил .dylib (macOS аналог .dll)

<ins>Что такое .dylib?</ins>

Файл с расширением файла DYLIB является файлом динамической библиотеки Mach-O (Mach Object), который приложение ссылается во время выполнения, чтобы выполнять определенные функции по мере необходимости.

Mach-O - это формат файла, который используется для различных типов файлов, включая объектный код, общие библиотеки, дампы ядра и исполняемые файлы, поэтому они могут содержать общие данные, которые несколько приложений могут повторно использовать с течением времени.

4. Сохранил файл .dylib в проекты на C# и на Java
5. В Используя атрибут DLLImport, "законнектил" декларацию функций в C# с их определением в .dylib
6. В Java с помощью внешне установленной библиотеки JNA создал .class на основе interface, содержащего функции, совпадающие по сигнатуре с функциями в .dylib

### Сложности и ограничения:

-Нужно подключать и настраивать дополнительные инструменты, которые обычно не используются

-Нет простого способа изменять .dylib/.dll. Нужно изменять source-код на C++, build-ить и только после этого получить новую .dylib/.dll

-Нельзя в качестве аргументов использовать не стандартные типы, ибо в другом языке не получится сопоставить сигнатуру и при интеропе линковка с .dylib/.dll не произойдёт


### <ins>Task 2</ins>
Написать немного кода на Scala и F# с использованием уникальных возможностей языка - Pipe operator, Discriminated Union, Computation expressions и т.д. . Вызвать написанный код из обычных соответствующих ООП языков (Java и С#) и посмотреть во что превращается написанный раннее код после декомпиляции в них. 

Процесс C#/F#:
1. Познакомился с F#: println, let, type, аргументы у функций
2. Создал 3 файла на каждую из фичей: Pipe operator, Discriminated union, Computation expression
3. Создал проект на C#, добавил refernce на F# проект и запустил созданные функции
4. Вбил код на F# в sharplab.io, дабы посмотреть, как его .NET декомпилирует в C#

Процесс Java/Scala:
1. Установил Scala в Intellij IDEA и добавил в модуль проекта
2. Познакомился со Scala: object, class, case class, def и определение фунции, наследование extends
3. Написал 2 скрипта на каждую из двух фичей: Pattern matching и особая форма цикла For c условием
4. В том же проекте создал файл .java и вызвал оттуда функции из Scala
5. Открыл .class, соотвествующий коду на Scala, чтобы посмотреть, в какой код на Java переведёт его JVM


### Вывод:
-Java и Scala компилируются в один и тот же байткод JVM, поэтому могут быть использованы в одном проекте

-C# и F# компилируются в IL, поэтому с добавлением refernce могут обмениваться функционалом между проектами


### <ins>Task 3</ins>
Написать алгоритм обхода графа (DFS и BFS) на языке Java, собрать в пакет и опубликовать (хоть в Maven, хоть в Gradle, не имеет значения). Использовать в другом проекте на Java/Scala этот пакет. Повторить это с C#/F#. В отчёте написать про алгоритм работы пакетных менеджеров, особенности их работы в C# и Java мирах.

Процесс Java:
1. Написал DFS и BFS на Java и с помощью инструментов Intellij IDEA создал .jar файл
2. Подключил Maven Framework и подготовил pom.xml файл для сборки пакета
3. Собрал .jar из Maven проекта
4. Чтобы теперь нам в новом проекте воспользоваться нашей библиотекой .jar, нам нужно пометстить подключить Maven framework и добавить dependency в файл pom.xml с соответствующими groupId, artifactId и version тегами
5. Использовал функционал, добавленный вместе с библиотекой таким образом. (Несмотря на то, что я не сделал это со своим пакетом, я сделал это во время выполнения следующего пункта лабораторной)
6. Проверил работу .jar в Java/Scala в отдельном проекте

   <ins>UPD:</ins>
   
   • Получил репозиторий на Maven Central, но добавить туда свой пакет оказалось ~~адской дрочильней~~ весьма сложно и времязатратно

Процесс C#:
1. Создал проект с начально конфигурацией "Class Library"
2. Написал DFS и BFS на С# и с помощью инструментов Finder нашёл созданную после build-а .dll
3. Загрузил пакет с .dll в другой проект и добавил refernce на файл .dll
4. Попробовал вызов функционала .dll из C# и из F# проектов

   <ins>UPD:</ins>

   • Поставим соотвествующую опцию, сгенерировал файл .nupkg во время build-а

   • Разместил пакет на сайте nuget.org: https://www.nuget.org/packages/Csharp_3/1.0.0

   • Протестировал, подключив NuGet пакет в отдельном solution

<ins>Что такое пакетные менеджеры и зачем они нужны?</ins>
 Пакетные менеджеры упрощают использование чужого кода, предоставляя этот код в виде независимых модулей — пакетов. Эти пакеты подключаются к своему коду по принципу чёрных ящиков — нам не важно как всё устроено внутри этого ящика (хоть и в некоторых случаях мы можем с лёгкостью посмотреть это), но мы знаем, что он делает. Благодаря такой слабосвязанной архитектуре появляется возможность легко обновлять чужой код или заменять один пакет другим со схожей функциональностью.
 
 У каждого пакетного менеджера есть файл с настройками, в котором нам нужно указать от каких пакетов зависит наш код, чтобы пакетный менеджер их скачал и установил к нам в систему. При этом каждый пакет может зависеть от других пакетов. Пакетный менеджер распутывает эту систему зависимостей и устанавливает всё что нужно, поэтому их ещё называют менеджерами зависимостей.


### <ins>Task 4</ins>
Изучить инструменты для оценки производительности в C# и Java. Написать несколько алгоритмов сортировок (и взять стандартную) и запустить бенчмарки (в бенчмарках помимо времени выполнения проверить аллокации памяти). В отчёт написать про инструменты для бенчмаркинга, их особености, анализ результатов проверок.

Процесс:
1. На C# и Java написал сортировки Bubble sort, Merge sort и Quick sort
2. Создал общих класс Sort, который содержит массив целых чисел как поле и сортирует этот массив всеми должными способами по заданию: мои сортировки и стандартная сортировка
3. В C# использовал пакет для измерений производительности BenchmarkDotNet, который был установлен с помощью NuGet пакет менеджера
4. Добавил требуемые атрибуты для отслеживания выполнения!
5. Получил результат

<img width="742" alt="Screenshot 2022-03-03 at 23 00 24" src="https://user-images.githubusercontent.com/37060880/156707107-9fa4bbea-85da-4638-8fbd-dacd2c2fe568.png">

<img width="732" alt="Screenshot 2022-03-03 at 23 04 41" src="https://user-images.githubusercontent.com/37060880/156707090-3af3d883-debd-4acc-af4f-672e7acd7c81.png">

6. Для Java воспользовал Maven Framework и добавление dependencies для установки библиотеки jmh-core-1.34.jar, которая отвечает за бенчмарк в Java
7. Так же расставил требуемые атрибуты и получил результат:


Result "src.main.java.Sort.BubbleSortBenchmark":
  N = 7
  mean =   1375.080 ±(99.9%) 4074.936 us/op
  
  
Result "src.main.java.Sort.DefaultSortBenchmark":
  N = 7
  mean =    361.001 ±(99.9%) 576.744 us/op
  
  
Result "src.main.java.Sort.MergeSortBenchmark":
  N = 7
  mean =    776.409 ±(99.9%) 1550.454 us/op
  
  
Result "src.main.java.Sort.QuickSortBenchmark":
  N = 7
  mean =    464.966 ±(99.9%) 1480.167 us/op
  
  По инфомации от студентов и преподавателей, отслежить в бенчмарках Java слишком сложная задача, поэтому аллокация не вошла в результат
  В каждом из пакетов с бенчмарками есть данные о warm up итерациях, которые можно настроить. В Java, например, после нескольких вызовов функции JVM пытается перевести её в байткод для оптимизации процесса
  
  Судя по бенчмаркам (от самого медленного к самому быстрому):
  1. Bubble sort
  2. Merge sort
  3. Quick sort
  4. Std sort

По количеству занимаемой памяти с большим отрывом выделяется Merge sort, ибо, как известно, в процессе инициализируется большое количество подмассивов


### <ins>Task 5</ins>
Используя инструменты dotTrace, dotMemory, всё-что-угодно-хоть-windbg, проанализировать работу написанного кода для бекапов. Необходимо написать сценарий, когда в цикле будет выполняться много запусков, будут создаваться и удаляться точки. Проверить два сценария: с реальной работой с файловой системой и без неё. В отчёте неоходимо проанализировать полученные результаты, сделать вывод о написанном коде. Опционально: предложить варианты по модернизации или написать альтернативную имплементацию.

Процесс:
1. Установил command-line dotMemory для macOS
2. В бекапах написал тест, который создаёт 15 бекап джоб и в каждой по рестор поинту (два варианта: с реальной файловой системой и с виртуальной файловой системой)
3. С помощью Thread.Sleep(), ##dotMemory["get-snapshot", {pid:&lt;pid&gt;}] и ##dotMemory["force-gc", {pid:&lt;pid&gt;}] сделал 3 snap shot-а:
  -В начале работы
  -После создания 15 джоб
  -После распаковки 15 рестор поинтов,
  
  перед последним (после завершения работы метода с джобами) принудительно запустим GC (Garbage collector)
  
4. Результат:
 
 Реальная файловая система:
![image_2022-03-11_01-41-22](https://user-images.githubusercontent.com/37060880/157767314-46407481-c990-4650-a5b6-efd3b6455fec.png)

Виртуальная файловая система:
![image_2022-03-11_01-41-33](https://user-images.githubusercontent.com/37060880/157767326-179df91e-752a-4cf6-89a1-48c19626ed3f.png)


### Анализ увиденного:  

#### Общая характеристика процесса:

Видно, как сначала память не изменяется
  
При появлении листа джоб возрастает сразу после его создания
  
Потом начинается процесс создания джоб и рестор поинтов (.zip в случае реальной файловой системы, заполнение массива string в случае виртуальной файловой системы). Занимаемая память линейно возрастает
  
В конце распаковки метод заканчивает выполнять свой функционал, и начинается процесс удаления объектов после выхода из метода. Запускается Garbage collector. Занимаемая память падает

#### Сравнение:

По графикам видно, что реальная файловая система занимает меньше памяти для хранения файлов, чем вирутальная файловая система. И в то же время виртуальная файловая система работает немного быстрее, чем реальная.

Мне показалось это странным. Я попробовал убрать взаимодействие с рестор поинтами и оставить только создание джоб.

Результат:

Реальная:
![image_2022-03-11_02-15-34](https://user-images.githubusercontent.com/37060880/157771185-c8864d29-5686-42c6-8b9c-1be10ec6de9e.png)

Виртуальная:
![image_2022-03-11_02-15-43](https://user-images.githubusercontent.com/37060880/157771196-a78c398c-ea14-433d-a43a-cd1fd68530f7.png)

Можно заметить, что в случае реальной системы занимается намного больше места на куче как Heap generation 0, так и Heap generation 1.

Я решил проверить результат, если убрать добавление Job Object (то есть добавления экземпляров класса, содержащего лишь путь к файлу)

Реальная:
![image_2022-03-11_02-29-32](https://user-images.githubusercontent.com/37060880/157772708-0ce5ba52-62ea-4d1e-80b6-9ccac4c48e20.png)

Виртуальная:
![image_2022-03-11_02-29-40](https://user-images.githubusercontent.com/37060880/157772719-969eb766-4a7d-4aaf-b339-ef0706f6c92a.png)

Теперь уменьшилось количество занимаемой памяти Heap generation 1, но реальная система до сих пор выделается в плане занимаемой памяти в Heap generation 0.

![image_2022-03-11_03-06-11](https://user-images.githubusercontent.com/37060880/157776183-f8498015-c6d7-466d-8bf3-3b48ea80e9c0.png)

Проанализировав представленную диаграмму, я заметил, что те байты, которые разделяют наши файловые системы относятся к каким-то Buffered file stream.

Поменяв реальный логгер на виртуальный, который записывает логи в список строк вместо файла, удалось получить такой результат:
![image_2022-03-11_03-08-45](https://user-images.githubusercontent.com/37060880/157776452-399fd2ff-ad0d-4915-a448-c5f17b285a56.png)

После последнего изменения реальная файловая система имеет показатель в 404.2 KB против виртульной файловой системы с показателем в 330.2 KB. Можно увидеть, что у нас всё ещё осталось 60.4 KB лишних в реальной системе. Компенсировать их можно путём отключения файлового вывода в JSON.

Итог:

-Виртульная файловая система работает быстрее, так как хранение файлов осуществляется в оперативной памяти и в варианте с виртуальной системой нет zip сжатия

-По идее виртульная файловая система должна занимать сравнительно столько же памяти, сколько и реальная, но из-за особенности ПО занимает заметно меньше (по крайней мере в нашем примере с файлами объёмом в несколько байт: "Hello, world!" и "Hello, OOP!")
