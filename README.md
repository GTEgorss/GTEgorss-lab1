# GTEgorss
Programming technologies (.NET: C#, F#; JVM: Java, Scala)

##LAB-1: Interop and learning about new programming and developing tools


### <ins>Task 1</ins>
Изучить механизм интеропа между языками, попробовать у себя вызывать C/C++ (Не C++/CLI) код (суммы чисел достаточно) из Java и C#. В отчёте описать логику работы, сложности и ограничения этих механизмов.

Процесс:
1. Написал на С++ две функции: sum(int a, int b) и int mult()
2. Добавил в заголовочный файл extern и __declspec(dllexport), чтобы функции в библиотеке после сборки соотвествовале по сигнатуре функциям из source-кода
3. Изменил в CMake файле add_executable на add_library, и добавил в аргументы имя заголовочного файла. В результате этого получил .dylib (macOS аналог .dll)

<ins>Что такое .dylib?</ins>

Файл с расширением файла DYLIB является файлом динамической библиотеки Mach-O (Mach Object), который приложение ссылается во время выполнения, чтобы выполнять определенные функции по мере необходимости.

Mach-O - это формат файла, который используется для различных типов файлов, включая объектный код, общие библиотеки, дампы ядра и исполняемые файлы, поэтому они могут содержать общие данные, которые несколько приложений могут повторно использовать с течением времени.

4. Сохранил файл .dylib в проекты на C# и на Java
5. В Используя атрибут DLLImport, "законнектил" декларацию функций в C# с их определением в .dylib
6. В Java с помощью внешне установленной библиотеки JNA создал .class на основе interface, содержащего функции, совпадающие по сигнатуре с функциями в .dylib

### Сложности и ограничения:

-Нужно подключать и настраивать дополнительные инструменты, которые обычно не используются
-Нет простого способа изменять .dylib/.dll. Нужно изменять source-код на C++, build-ить и только после этого получить новую .dylib/.dll
-Нельзя в качестве аргументов использовать не стандартные типы, ибо в другом языке не получится сопоставить сигнатуру и при интеропе линковка с .dylib/.dll не произойдёт


### <ins>Task 2</ins>
Написать немного кода на Scala и F# с использованием уникальных возможностей языка - Pipe operator, Discriminated Union, Computation expressions и т.д. . Вызвать написанный код из обычных соответствующих ООП языков (Java и С#) и посмотреть во что превращается написанный раннее код после декомпиляции в них. 

Процесс C#/F#:
1. Познакомился с F#: println, let, type, аргументы у функций
2. Создал 3 файла на каждую из фичей: Pipe operator, Discriminated union, Computation expression
3. Создал проект на C#, добавил refernce на F# проект и запустил созданные функции
4. Вбил код на F# в sharplab.io, дабы посмотреть, как его .NET декомпилирует в C#

Процесс Java/Scala:
1. Установил Scala в Intellij IDEA и добавил в модуль проекта
2. Познакомился со Scala: object, class, case class, def и определение фунции, наследование extends
3. Написал 2 скрипта на каждую из двух фичей: Pattern matching и особая форма цикла For c условием
4. В том же проекте создал файл .java и вызвал оттуда функции из Scala
5. Открыл .class, соотвествующий коду на Scala, чтобы посмотреть, в какой код на Java переведёт его JVM


### Вывод:
-Java и Scala компилируются в один и тот же байткод JVM, поэтому могут быть использованы в одном проекте
-C# и F# компилируются в IL, поэтому с добавлением refernce могут обмениваться функционалом между проектами


### <ins>Task 3</ins>
Написать алгоритм обхода графа (DFS и BFS) на языке Java, собрать в пакет и опубликовать (хоть в Maven, хоть в Gradle, не имеет значения). Использовать в другом проекте на Java/Scala этот пакет. Повторить это с C#/F#. В отчёте написать про алгоритм работы пакетных менеджеров, особенности их работы в C# и Java мирах.

Процесс Java:
1. Написал DFS и BFS на Java и с помощью инструментов Intellij IDEA создал .jar файл
2. Подключил Maven Framework и подготовил pom.xml файл для публикации в Maven Central
3. Получил репозиторий на Maven (на этом пункте возникли проблемы, я его ещё не получил)
4. Загружаем подготовленные артефакты в Maven репозиторий
5. Чтобы теперь нам в новом проекте воспользоваться нашей библиотекой .jar, нам нужно пометстить подключить Maven framework и добавить dependency в файл pom.xml с соответствующими groupId, artifactId и version тегами
6. Использовал функционал, добавленный вместе с библиотекой таким образом. (Несмотря на то, что я не сделал это со своим пакетом, я сделал это во время выполнения следующего пункта лабораторной)
7. Проверил работу .jar в Java/Scala в отдельном проекте

Процесс C#:
1. Создал проект с начально конфигурацией "Class Library"
2. Написал DFS и BFS на С# и с помощью инструментов Finder нашёл созданную после build-а .dll
3. Опубликовал эту библиотеку в пакетном менеджере (та же проблема, что и в Java)
4. Загрузил пакет с .dll в другой проект и добавил refernce на файл .dll
5. Попробовал вызов функционала .dll из C# и из F# проектов
